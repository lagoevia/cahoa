# Appendix A - Just Read it

| Appendix Home | First Page | Previous Page | Next Page | Last Page |
|---------------|------------|---------------|-----------|-----------|
| [Just Read It](HOME.md) | [Documentation](DOCS.md)   | [Asking questions](ASK.md)    | No next page  | [Tackling problems](TACKLE.md)  |

## I want to solve this problem, but I'm stuck/demotivated
Problem solving is complicated, and takes time to do right, regardless of your experience. With that in mind, here are some thoughts of how you should approach problem solving, that have helped me improve over time and be able to solve more problems confidently.

## How To Tackle A Problem
The following is an excerpt from a conversation in discord, where an user was trying to help another user:

> I was going to write up something for the help, but I realize how annoying it is to be mid-teaching and have someone barge in. As a quick summary though, without interruption to the actual conversation between JM and Lucid, problems like that can be broken down to the following steps:<br><br>1. Understand the problem (the step they’re on now). Start from a general sense and gradually “walk down the abstraction layers” so that you understand everything. Even if you do not have someone to talk back and forth with, it helps if you structure it in the same way (talking to yourself) as you can catch many assumptions and gaps in your logic that you may be tempted to rush past by. It’s tempting once you have 60% of the problem understood to jump ahead from excitement but then have to go back in steps, causing loss of motivation and time waste.<br><br>2. Once the problem is fully understood, devise a solution (non code). Here, it’d be something like “ok so to save the parking spot people would need to use a command” and so on. Check to see that all of the aspects of the problem on 1 are addressed in your solution.<br><br>3. Evaluate technical assets available. What stuff do you know that could be useful in applying the solutions in code? Iterators, arrays, bit vectors, whatever. These are things that you will use in the actual implementation of your solution.<br><br>4. Implement the solution, with the help of tools from 3, that matches your solution 2 to problem 1. You may have to go back to see if you missed things, or similarly if you found another helpful tool or way to address the solution.<br><br>The “going back” steps is what is demotivating and leads to stop working on something. The gradual steps serve as a guide to know when one part of the problem solving process is done and when the next one I’d ready to be practically started rather than just rush them and have to go back later

## Conclusion
With that approach, you should be less prone to have to "jump back" to earlier steps, which is, as I said on the message, the thing that discourages people the most. Through time and effort, you'll get more experience which will help you be more confident in your abilities and comfortable in approaching new/old problems.